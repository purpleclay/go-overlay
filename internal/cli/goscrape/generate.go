package goscrape

import (
	"bytes"
	"cmp"
	"fmt"
	"html/template"
	"io"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"time"

	"github.com/purpleclay/chomp"
	"github.com/purpleclay/go-overlay/internal/github"
	"github.com/purpleclay/go-overlay/internal/scrape"
	"github.com/sourcegraph/conc/pool"
	"github.com/spf13/cobra"
)

const nixManifestTemplate = `# Auto-generated by go-scrape - do not edit manually
{
  version = "{{.Version }}";
  date = "{{.Date}}";
{{range .Targets}}
  "{{.System}}" = {
    sha256 = "{{.SHA256}}";
    url = "{{.URL}}";
  };
{{- end}}
}
`

var (
	// Mapping from Go's website OS+Arch naming to Nix system identifiers
	// Only include platforms that Nix actually supports
	goToNixSystem = map[string]string{
		"macOSx86-64":   "x86_64-darwin",
		"macOSARM64":    "aarch64-darwin",
		"Linuxx86-64":   "x86_64-linux",
		"LinuxARM64":    "aarch64-linux",
		"Linuxx86":      "i686-linux",
		"LinuxARMv6":    "armv7l-linux",
		"Linuxriscv64":  "riscv64-linux",
		"Linuxppc64le":  "powerpc64le-linux",
		"Linuxs390x":    "s390x-linux",
		"Linuxloong64":  "loongarch64-linux",
		"FreeBSDx86-64": "x86_64-freebsd",
		"FreeBSDARM64":  "aarch64-freebsd",
		"FreeBSDx86":    "i686-freebsd",
	}

	nixTemplate = template.Must(template.New("nix").Parse(nixManifestTemplate))
)

// Target contains the core details for Nix to download a copy
// of Go for any supported OS-Arch combination
type Target struct {
	SHA256 string
	URL    string
	System string
}

// Scrape contains the scraped output from the Go [Download] website, ready
// for serialisation into a Nix attribute set.
//
// [Download]: https://go.dev/dl/
type Scrape struct {
	Date    string
	Version string
	Targets []Target
}

func (s *Scrape) String() string {
	var buf bytes.Buffer
	if err := nixTemplate.Execute(&buf, s); err != nil {
		return fmt.Sprintf("failed to generate nix manifest: %v\n", err)
	}

	return buf.String()
}

func (s *Scrape) Filename() string {
	return s.Version + ".nix"
}

func parse(page string, version string, date time.Time) (*Scrape, error) {
	s := &Scrape{
		Date:    date.Format(time.DateOnly),
		Version: strings.TrimPrefix(version, "go"),
	}

	var ext []string
	var err error

	rem := page
	for {
		if rem, ext, err = chomp.Pair(scrape.Href(version), scrape.Target())(rem); err != nil {
			break
		}

		// ext[0] = URL path (e.g., "/dl/go1.22.4.linux-amd64.tar.gz")
		// ext[1] = Kind (Archive, Installer, Source)
		// ext[2] = OS
		// ext[3] = Arch
		// ext[4] = Size
		// ext[5] = SHA256

		if ext[1] != "Archive" {
			continue
		}

		goKey := ext[2] + ext[3]
		nixSystem, ok := goToNixSystem[goKey]
		if !ok {
			continue
		}

		target := Target{
			SHA256: ext[5],
			URL:    "https://go.dev" + ext[0],
			System: nixSystem,
		}
		s.Targets = append(s.Targets, target)
	}

	return s, nil
}

func newGenerateCmd(out io.Writer) *cobra.Command {
	var outputDir string

	cmd := &cobra.Command{
		Use:   "generate [version...]",
		Short: "Generate Nix manifests for Go versions",
		Long: `Scrapes the Golang website (https://go.dev/dl/) for specified releases and generates
Nix manifest files with SHA256 hashes for each platform.

Versions can be specified with or without the "go" prefix (e.g., "1.21.1" or "go1.21.1").
Multiple versions can be scraped in a single command.

The output format is compatible with go-overlay and uses Nix system identifiers
(e.g., x86_64-linux, aarch64-darwin) as keys.`,
		Example: `  # Generate manifest for the latest available version and write to stdout
  $ go-scrape generate

  # Generate manifest for a specified version of Golang
  $ go-scrape generate go1.20.13

  # Generate manifests for multiple versions
  $ go-scrape generate 1.20.13 1.21.6 1.22.0

  # Generate manifests for all minor versions of a major version
  $ go-scrape generate 1.23*

  # Generate manifests and write to directory
  $ go-scrape generate 1.21.6 --output ./manifests`,
		SilenceUsage:  true,
		SilenceErrors: true,
		RunE: func(cmd *cobra.Command, args []string) error {
			page, ok := cmd.Context().Value(pageDataKey).(string)
			if !ok {
				return fmt.Errorf("failed to retrieve page data from context")
			}

			var versions []string
			if len(args) == 0 {
				latestVersion, err := detectVersion(page, "")
				if err != nil {
					return err
				}
				versions = append(versions, latestVersion)
			} else {
				for _, arg := range args {
					version := arg
					if strings.HasSuffix(arg, "*") {
						allVersions, err := listVersions(page, strings.TrimSuffix(version, "*"))
						if err != nil {
							return err
						}
						versions = append(versions, allVersions...)
					} else {
						versions = append(versions, version)
					}
				}
			}

			if outputDir != "" {
				if err := os.MkdirAll(outputDir, 0o755); err != nil {
					return fmt.Errorf("failed to create output directory: %w", err)
				}
			}

			p := pool.NewWithResults[*Scrape]().WithMaxGoroutines(10).WithErrors()

			for _, ver := range versions {
				p.Go(func() (*Scrape, error) {
					downloadSection, _, err := scrape.SeekDownloadSection(ver)(page)
					if err != nil {
						return nil, fmt.Errorf("failed to find download section for %s: %w", ver, err)
					}

					releaseDate, err := github.FetchReleaseDate(ver)
					if err != nil {
						fmt.Fprintf(os.Stderr, "warning: %s - using current date\n", err)
						releaseDate = time.Now().UTC()
					}

					return parse(downloadSection, ver, releaseDate)
				})
			}

			results, err := p.Wait()
			if err != nil {
				return err
			}

			slices.SortFunc(results, func(a, b *Scrape) int {
				return cmp.Compare(a.Version, b.Version)
			})

			for _, s := range results {
				if outputDir != "" {
					filename := s.Filename()
					path := filepath.Join(outputDir, filename)
					if err := os.WriteFile(path, []byte(s.String()), 0o644); err != nil {
						return err
					}
				} else {
					fmt.Fprintf(out, "%s", s.String())
				}
			}

			return nil
		},
	}

	cmd.Flags().StringVarP(&outputDir, "output", "o", "", "the directory path for writing generated .nix files")
	return cmd
}
