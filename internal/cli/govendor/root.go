package govendor

import (
	"bytes"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/fs"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"sync"

	"github.com/BurntSushi/toml"
	"github.com/charlievieth/fastwalk"
	"github.com/nix-community/go-nix/pkg/nar"
	"github.com/sourcegraph/conc/pool"
	"github.com/spf13/cobra"
	"golang.org/x/mod/modfile"
)

const (
	vendorFile     = "govendor.toml"
	goModFile      = "go.mod"
	manifestHeader = "# Generated by govendor. DO NOT EDIT.\n\n"
)

var (
	errNoDependencies = fmt.Errorf("no dependencies")
	errDriftDetected  = fmt.Errorf("drift detected")
)

//nolint:tagliatelle
type goModuleMetadata struct {
	Path    string `json:"Path"`
	Version string `json:"Version"`
	Dir     string `json:"Dir"`
	GoMod   string `json:"GoMod"`
}

type vendorManifest struct {
	Schema int                 `toml:"schema"`
	Hash   string              `toml:"hash"`
	Mod    map[string]goModule `toml:"mod"`
}

type goModule struct {
	Path         string   `toml:"-"`
	Version      string   `toml:"version"`
	Hash         string   `toml:"hash"`
	GoVersion    string   `toml:"go,omitempty"`
	Packages     []string `toml:"packages,omitempty"`
	ReplacedPath string   `toml:"replaced,omitempty"`
}

var skipDirs = map[string]bool{
	"__pycache__":  true,
	".cache":       true,
	".devenv":      true,
	".direnv":      true,
	".git":         true,
	".terraform":   true,
	".venv":        true,
	"build":        true,
	"dist":         true,
	"node_modules": true,
	"result":       true,
	"target":       true,
	"testdata":     true,
	"vendor":       true,
}

func Execute(out io.Writer) error {
	var (
		recursive  bool
		depth      int
		quiet      bool
		checkPaths []string
	)

	cmd := &cobra.Command{
		Use:   "go-vendor",
		Short: "Generate a vendor manifest for building Go applications with Nix",
		Long: `Generate a govendor.toml manifest containing Go module metadata for use
with go-overlay's buildGoApplication Nix function.

The manifest includes module versions, NAR hashes, Go version requirements,
and package lists. This metadata enables Nix to build Go applications using
vendored dependencies without requiring nixpkgs' patched Go toolchain.`,
		Example: `  # Generate vendor manifest for current go.mod
  govendor

  # Recursively scan for go.mod files, limiting depth to 2 directories
  govendor --recursive --depth 2

  # Check if a manifest has drifted and needs updating
  govendor --check

  # Check directories for manifest files that have drifted
  govendor --check ./api,./web/

  # Recursively check for manifest files that have drifted, limiting depth to 2 directories
  govendor --check --recursive --depth 2`,
		SilenceUsage:  true,
		SilenceErrors: true,
		RunE: func(cmd *cobra.Command, _ []string) error {
			w := out
			if quiet {
				w = io.Discard
			}

			if cmd.Flags().Changed("check") {
				if recursive {
					return scanAndCheck(w, depth)
				}
				return checkAll(w, checkPaths)
			}

			if recursive {
				return scanAndVendor(w, depth)
			}
			return vendor(w, ".")
		},
	}

	cmd.Flags().BoolVarP(&recursive, "recursive", "r", false, "recursively scan for go.mod files")
	cmd.Flags().IntVarP(&depth, "depth", "d", 0, "limit directory traversal depth (0 = unlimited, requires --recursive)")
	cmd.Flags().BoolVarP(&quiet, "quiet", "q", false, "suppress output except errors")
	cmd.Flags().StringSliceVarP(&checkPaths, "check", "c", nil, "check if manifests have drifted and need updating (accepts paths to govendor.toml files)")
	cmd.Flag("check").NoOptDefVal = "."
	return cmd.Execute()
}

func scanAndVendor(out io.Writer, maxDepth int) error {
	root, err := os.Getwd()
	if err != nil {
		return err
	}

	var modDirs []string
	var mu sync.Mutex

	conf := fastwalk.Config{
		Follow:   false,
		MaxDepth: maxDepth,
	}

	err = fastwalk.Walk(&conf, root, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if d.IsDir() {
			if skipDirs[d.Name()] {
				return fastwalk.SkipDir
			}
			return nil
		}

		if d.Name() == goModFile {
			mu.Lock()
			modDirs = append(modDirs, filepath.Dir(path))
			mu.Unlock()
		}

		return nil
	})
	if err != nil {
		return err
	}

	if len(modDirs) == 0 {
		fmt.Fprintln(out, "no go.mod files found")
		return nil
	}

	sort.Strings(modDirs)

	var errs []error
	var skipped int
	for _, dir := range modDirs {
		relDir, _ := filepath.Rel(root, dir)
		if relDir == "" {
			relDir = "."
		}
		if err := vendor(out, dir); err != nil {
			if errors.Is(err, errNoDependencies) {
				fmt.Fprintf(out, "skipping %s - no dependencies\n", relDir)
				skipped++
				continue
			}
			errs = append(errs, fmt.Errorf("%s: %w", relDir, err))
		}
	}

	if skipped > 0 {
		fmt.Fprintf(out, "found %d modules (%d skipped)\n", len(modDirs), skipped)
	} else {
		fmt.Fprintf(out, "found %d modules\n", len(modDirs))
	}

	if len(errs) > 0 {
		return fmt.Errorf("errors occurred: %v", errs)
	}

	return nil
}

func vendor(out io.Writer, dir string) error {
	goModPath := filepath.Join(dir, goModFile)
	data, err := os.ReadFile(goModPath)
	if err != nil {
		return err
	}

	goMod, err := modfile.Parse(goModPath, data, nil)
	if err != nil {
		return err
	}

	if len(goMod.Require) == 0 {
		return errNoDependencies
	}

	replacements := make(map[string]string)
	for _, repl := range goMod.Replace {
		replacements[repl.New.Path] = repl.Old.Path
	}

	pkgsByMod, err := packagesByModule(goMod.Module.Mod.Path, dir)
	if err != nil {
		return err
	}

	downloads, err := downloadModules(dir)
	if err != nil {
		return err
	}

	goModules, err := resolveGoModules(downloads, pkgsByMod, replacements)
	if err != nil {
		return err
	}

	mod := map[string]goModule{}
	for _, m := range goModules {
		mod[m.Path] = m
	}

	manifest := &vendorManifest{
		Schema: 1,
		Hash:   hashGoMod(data),
		Mod:    mod,
	}

	var buf bytes.Buffer
	buf.WriteString(manifestHeader)

	encoder := toml.NewEncoder(&buf)
	if err := encoder.Encode(manifest); err != nil {
		return err
	}

	outputPath := filepath.Join(dir, vendorFile)
	if err := os.WriteFile(outputPath, buf.Bytes(), 0o644); err != nil {
		return err
	}

	fmt.Fprintf(out, "wrote %s with %d modules\n", outputPath, len(manifest.Mod))
	return nil
}

func scanAndCheck(out io.Writer, maxDepth int) error {
	root, err := os.Getwd()
	if err != nil {
		return err
	}

	var manifestDirs []string
	var mu sync.Mutex

	conf := fastwalk.Config{
		Follow:   false,
		MaxDepth: maxDepth,
	}

	err = fastwalk.Walk(&conf, root, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if d.IsDir() {
			if skipDirs[d.Name()] {
				return fastwalk.SkipDir
			}
			return nil
		}

		if d.Name() == vendorFile {
			mu.Lock()
			manifestDirs = append(manifestDirs, filepath.Dir(path))
			mu.Unlock()
		}

		return nil
	})
	if err != nil {
		return err
	}

	if len(manifestDirs) == 0 {
		fmt.Fprintln(out, "no govendor.toml files found")
		return nil
	}

	sort.Strings(manifestDirs)

	var drifted int
	for _, dir := range manifestDirs {
		if err := checkDrift(out, dir); err != nil {
			if errors.Is(err, errDriftDetected) {
				drifted++
				continue
			}
			return err
		}
	}

	if drifted > 0 {
		return errDriftDetected
	}
	return nil
}

func checkAll(out io.Writer, paths []string) error {
	var drifted int
	for _, path := range paths {
		dir := path
		if filepath.Base(path) == vendorFile {
			dir = filepath.Dir(path)
		}

		if err := checkDrift(out, dir); err != nil {
			if errors.Is(err, errDriftDetected) {
				drifted++
				continue
			}
			return err
		}
	}

	if drifted > 0 {
		return errDriftDetected
	}
	return nil
}

func checkDrift(out io.Writer, dir string) error {
	goModPath := filepath.Join(dir, goModFile)
	data, err := os.ReadFile(goModPath)
	if err != nil {
		return err
	}

	outputPath := filepath.Join(dir, vendorFile)
	existingData, err := os.ReadFile(outputPath)
	if err != nil {
		if os.IsNotExist(err) {
			fmt.Fprintf(out, "%s does not exist\n", outputPath)
			return errDriftDetected
		}
		return err
	}

	var existing vendorManifest
	if err := toml.Unmarshal(existingData, &existing); err != nil {
		return err
	}

	currentHash := hashGoMod(data)
	if existing.Hash != currentHash {
		fmt.Fprintf(out, "%s is out of date\n", outputPath)
		return errDriftDetected
	}

	fmt.Fprintf(out, "%s is up to date\n", outputPath)
	return nil
}

func hashGoMod(data []byte) string {
	h := sha256.Sum256(data)
	return "sha256-" + base64.StdEncoding.EncodeToString(h[:])
}

func packagesByModule(ownModule, dir string) (map[string][]string, error) {
	cmd := []string{
		"go",
		"list",
		"-deps",
		"-f",
		fmt.Sprintf(`'{{if not .Standard}}{{if .Module}}{{if ne .Module.Path "%s"}}{{.Module.Path}}{{"\t"}}{{.ImportPath}}{{end}}{{end}}{{end}}'`, ownModule),
		"./...",
	}

	out, err := exec(cmd, dir)
	if err != nil {
		return nil, err
	}

	pkgsByMod := make(map[string][]string)
	for line := range strings.SplitSeq(out, "\n") {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}

		modPath, pkgPath, ok := strings.Cut(line, "\t")
		if !ok {
			continue
		}
		pkgsByMod[modPath] = append(pkgsByMod[modPath], pkgPath)
	}

	for modPath := range pkgsByMod {
		sort.Strings(pkgsByMod[modPath])
	}

	return pkgsByMod, nil
}

func downloadModules(dir string) ([]goModuleMetadata, error) {
	cmd := []string{
		"go",
		"mod",
		"download",
		"-json",
	}

	out, err := exec(cmd, dir)
	if err != nil {
		return nil, err
	}

	var downloads []goModuleMetadata
	dec := json.NewDecoder(strings.NewReader(out))
	for {
		var meta goModuleMetadata
		if err := dec.Decode(&meta); err == io.EOF {
			break
		} else if err != nil {
			return nil, err
		}
		downloads = append(downloads, meta)
	}

	return downloads, nil
}

func resolveGoModules(moduleMetadata []goModuleMetadata, pkgsByMod map[string][]string, replacements map[string]string) ([]goModule, error) {
	p := pool.NewWithResults[goModule]().WithErrors().WithMaxGoroutines(8)

	for _, meta := range moduleMetadata {
		p.Go(func() (goModule, error) {
			h := sha256.New()
			if err := nar.DumpPathFilter(h, meta.Dir, func(path string, _ nar.NodeType) bool {
				return strings.ToLower(filepath.Base(path)) != ".ds_store"
			}); err != nil {
				return goModule{}, err
			}

			digest := h.Sum(nil)
			hash := "sha256-" + base64.StdEncoding.EncodeToString(digest)

			var goVersion string
			if meta.GoMod != "" {
				if modData, err := os.ReadFile(meta.GoMod); err == nil {
					if modFile, err := modfile.Parse(meta.GoMod, modData, nil); err == nil && modFile.Go != nil {
						goVersion = modFile.Go.Version
					}
				}
			}

			path := meta.Path
			var replacedPath string
			if orig, ok := replacements[path]; ok {
				path = orig
				replacedPath = meta.Path
			}

			return goModule{
				Path:         path,
				Version:      meta.Version,
				Packages:     pkgsByMod[meta.Path],
				Hash:         hash,
				GoVersion:    goVersion,
				ReplacedPath: replacedPath,
			}, nil
		})
	}

	goModules, err := p.Wait()
	if err != nil {
		return nil, err
	}

	sort.Slice(goModules, func(i, j int) bool {
		return goModules[i].Path < goModules[j].Path
	})

	return goModules, nil
}
