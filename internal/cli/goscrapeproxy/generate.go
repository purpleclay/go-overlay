package goscrapeproxy

import (
	"bytes"
	"cmp"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"slices"
	"strings"
	"text/template"
	"time"

	"github.com/nix-community/go-nix/pkg/nar"
	"github.com/purpleclay/go-overlay/internal/mod"
	"github.com/purpleclay/go-overlay/internal/proxy"
	"github.com/sourcegraph/conc/pool"
	"github.com/spf13/cobra"
)

var nixPlatforms = []string{
	"linux/amd64",
	"linux/arm64",
	"darwin/amd64",
	"darwin/arm64",
}

const toolManifestTemplate = `# Auto-generated by goscrapeproxy - do not edit manually
{
  version = "{{ .Version }}";
  date = "{{ .Date }}";
  module = "{{ .Module }}";
  subPackages = [{{ range $i, $p := .SubPackages }}{{ if $i }} {{ end }}"{{ $p }}"{{ end }}];
  go = "{{ .Go }}";
  hash = "{{ .Hash }}";

  mod = {
{{- range .Modules }}
    "{{ .Path }}" = {
      version = "{{ .Version }}";
      hash = "{{ .Hash }}";
      go = "{{ .Go }}";
      packages = [{{ range $i, $p := .Packages }}{{ if $i }} {{ end }}"{{ $p }}"{{ end }}];
    };
{{- end }}
  };
}
`

var nixTemplate = template.Must(template.New("tool-manifest").Parse(toolManifestTemplate))

type toolManifest struct {
	Date        string
	Go          string
	Hash        string
	Module      string
	Modules     []toolModule
	SubPackages []string
	Version     string
}

type toolModule struct {
	Go       string
	Hash     string
	Packages []string
	Path     string
	Version  string
}

func (m *toolManifest) String() string {
	var buf bytes.Buffer
	if err := nixTemplate.Execute(&buf, m); err != nil {
		return fmt.Sprintf("failed to generate nix manifest: %v\n", err)
	}
	return buf.String()
}

func (m *toolManifest) Filename() string {
	return m.Version + ".nix"
}

func narHash(dir string) (string, error) {
	h := sha256.New()
	if err := nar.DumpPath(h, dir); err != nil {
		return "", err
	}
	return "sha256-" + base64.StdEncoding.EncodeToString(h.Sum(nil)), nil
}

func downloadModule(module, version string) (string, error) {
	cmd := exec.Command("go", "mod", "download", "-json", module+"@"+version)
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("go mod download failed: %s", strings.TrimSpace(stderr.String()))
	}

	//nolint:tagliatelle
	var result struct {
		Dir string `json:"Dir"`
	}
	if err := json.Unmarshal(stdout.Bytes(), &result); err != nil {
		return "", fmt.Errorf("failed to parse download output: %w", err)
	}

	return result.Dir, nil
}

func generateManifest(module, version string, subPackages []string) (*toolManifest, error) {
	var (
		info      *proxy.ModuleInfo
		goVersion string
		srcDir    string
	)

	g := pool.New().WithErrors()
	g.Go(func() error {
		var err error
		info, err = proxy.FetchInfo(module, version)
		return err
	})

	g.Go(func() error {
		raw, err := proxy.FetchGoMod(module, version)
		if err != nil {
			return err
		}
		goVersion, err = proxy.ParseGoDirective(raw)
		return err
	})

	g.Go(func() error {
		var err error
		srcDir, err = downloadModule(module, version)
		return err
	})

	if err := g.Wait(); err != nil {
		return nil, err
	}

	// Force -mod=mod to prevent Go from automatically enabling -mod=vendor
	// when the downloaded module source contains an in-tree vendor directory.
	// Without this, go list fails with incomplete vendored dependencies.
	// A future refactor of goscrapeproxy could thread extra env vars through
	// the Dependencies call chain instead of modifying process-level state.
	os.Setenv("GOFLAGS", "-mod=mod")
	defer os.Unsetenv("GOFLAGS")

	sourceHash, err := narHash(srcDir)
	if err != nil {
		return nil, err
	}

	goModFile, err := mod.ParseGoModFile(filepath.Join(srcDir, "go.mod"))
	if err != nil {
		return nil, err
	}

	// Only resolve packages for platforms supported by Nix â€” Windows is
	// excluded because Nix does not support it, and some tools (e.g. delve)
	// have platform sentinel files that break go list on Windows.
	deps, err := goModFile.Dependencies(nixPlatforms)
	if err != nil {
		return nil, err
	}

	modules := make([]toolModule, 0, len(deps))
	for _, d := range deps {
		modules = append(modules, toolModule{
			Path:     d.Path,
			Version:  d.Version,
			Hash:     d.Hash,
			Go:       d.GoVersion,
			Packages: d.Packages,
		})
	}

	return &toolManifest{
		Module:      module,
		Version:     strings.TrimPrefix(version, "v"),
		Date:        info.Time.Format(time.DateOnly),
		Go:          goVersion,
		Hash:        sourceHash,
		SubPackages: subPackages,
		Modules:     modules,
	}, nil
}

func resolveVersions(module string, patterns []string) ([]string, error) {
	if len(patterns) == 0 {
		all, err := proxy.ListVersions(module, "")
		if err != nil {
			return nil, err
		}
		if len(all) == 0 {
			return nil, fmt.Errorf("no versions found for module %s", module)
		}
		return all[len(all)-1:], nil
	}

	var versions []string
	for _, pattern := range patterns {
		if before, ok := strings.CutSuffix(pattern, "*"); ok {
			prefix := strings.TrimPrefix(before, "v")
			matched, err := proxy.ListVersions(module, prefix)
			if err != nil {
				return nil, err
			}
			versions = append(versions, matched...)
		} else {
			versions = append(versions, pattern)
		}
	}
	return versions, nil
}

func newGenerateCmd() *cobra.Command {
	var (
		outputDir       string
		subPackages     []string
		versionPatterns []string
	)

	cmd := &cobra.Command{
		Use:   "generate MODULE",
		Short: "Generate Nix manifests for Go tool versions",
		Long: `
		Queries the Go module proxy for version metadata, downloads the tool source,
		resolves dependencies and computes NAR hashes, and generates Nix manifest files.

		If no versions are specified, the latest version is generated.
		`,
		Example: `
		# Generate manifest for the latest version
		goscrapeproxy generate golang.org/x/vuln --sub-packages cmd/govulncheck \
		  --output manifests/govulncheck

		# Generate manifests for specific versions
		goscrapeproxy generate golang.org/x/vuln --sub-packages cmd/govulncheck \
		  --versions v1.1.3,v1.1.4 \
		  --output manifests/govulncheck

		# Generate manifests matching a glob pattern
		goscrapeproxy generate golang.org/x/vuln --sub-packages cmd/govulncheck \
		  --versions "v1.1*" \
		  --output manifests/govulncheck
       `,
		SilenceUsage:  true,
		SilenceErrors: true,
		Args:          cobra.ExactArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			module := args[0]

			versions, err := resolveVersions(module, versionPatterns)
			if err != nil {
				return err
			}

			if outputDir != "" {
				if err := os.MkdirAll(outputDir, 0o755); err != nil {
					return fmt.Errorf("failed to create output directory: %w", err)
				}
			}

			p := pool.NewWithResults[*toolManifest]().WithMaxGoroutines(4).WithErrors()

			for _, ver := range versions {
				p.Go(func() (*toolManifest, error) {
					return generateManifest(module, ver, subPackages)
				})
			}

			results, err := p.Wait()
			if err != nil {
				return err
			}

			slices.SortFunc(results, func(a, b *toolManifest) int {
				return cmp.Compare(a.Version, b.Version)
			})

			for _, m := range results {
				if outputDir != "" {
					path := filepath.Join(outputDir, m.Filename())
					if err := os.WriteFile(path, []byte(m.String()), 0o644); err != nil {
						return err
					}
				} else {
					fmt.Fprint(cmd.OutOrStdout(), m.String())
				}
			}

			return nil
		},
	}

	cmd.Flags().StringVarP(&outputDir, "output", "o", "", "directory path for writing generated .nix files")
	cmd.Flags().StringSliceVar(&subPackages, "sub-packages", nil, "sub-packages to build (e.g. cmd/govulncheck)")
	cmd.Flags().StringSliceVarP(&versionPatterns, "versions", "v", nil, "versions to generate, supports glob patterns (e.g. v1.1.3, \"v1.1*\")")

	cmd.MarkFlagRequired("sub-packages")
	return cmd
}
