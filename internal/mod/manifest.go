package mod

import (
	"io"
	"slices"

	"github.com/BurntSushi/toml"
)

const (
	schemaVersion  = 2
	manifestHeader = "# Generated by govendor. DO NOT EDIT.\n\n"
)

type VendorManifest struct {
	Schema           int                 `toml:"schema"`
	Version          string              `toml:"version,omitempty"`
	Hash             string              `toml:"hash"`
	IncludePlatforms []string            `toml:"include_platforms,omitempty"`
	Workspace        *WorkspaceConfig    `toml:"workspace,omitempty"`
	Mod              map[string]GoModule `toml:"mod"`
}

type WorkspaceConfig struct {
	Go        string   `toml:"go"`
	Toolchain string   `toml:"toolchain,omitempty"`
	Modules   []string `toml:"modules"`
}

type GoModule struct {
	Path         string   `toml:"-"`
	Version      string   `toml:"version"`
	Hash         string   `toml:"hash,omitempty"`
	GoVersion    string   `toml:"go,omitempty"`
	Packages     []string `toml:"packages,omitempty"`
	ReplacedPath string   `toml:"replaced,omitempty"`
	Local        string   `toml:"local,omitempty"`
}

func newManifest(goMod *GoModFile, platforms []string, includePlatforms []string, vendoredVersion string) (*VendorManifest, error) {
	deps, err := goMod.Dependencies(platforms)
	if err != nil {
		return nil, err
	}

	mod := make(map[string]GoModule, len(deps))
	for _, m := range deps {
		mod[m.Path] = m
	}

	var recorded []string
	if len(includePlatforms) > 0 {
		recorded = make([]string, len(includePlatforms))
		copy(recorded, includePlatforms)
		slices.Sort(recorded)
	}

	return &VendorManifest{
		Schema:           schemaVersion,
		Version:          vendoredVersion,
		Hash:             goMod.Hash(),
		IncludePlatforms: recorded,
		Mod:              mod,
	}, nil
}

func newWorkspaceManifest(goWork *GoWorkFile, platforms []string, includePlatforms []string, vendoredVersion string) (*VendorManifest, error) {
	deps, err := goWork.Dependencies(platforms)
	if err != nil {
		return nil, err
	}

	mod := make(map[string]GoModule, len(deps))
	for _, m := range deps {
		mod[m.Path] = m
	}

	var recorded []string
	if len(includePlatforms) > 0 {
		recorded = make([]string, len(includePlatforms))
		copy(recorded, includePlatforms)
		slices.Sort(recorded)
	}

	return &VendorManifest{
		Schema:           schemaVersion,
		Version:          vendoredVersion,
		Hash:             goWork.Hash(),
		IncludePlatforms: recorded,
		Workspace:        goWork.WorkspaceConfig(),
		Mod:              mod,
	}, nil
}

func (m *VendorManifest) WriteTo(w io.Writer) (int64, error) {
	n, err := io.WriteString(w, manifestHeader)
	if err != nil {
		return int64(n), err
	}

	encoder := toml.NewEncoder(w)
	if err := encoder.Encode(m); err != nil {
		return int64(n), err
	}

	return int64(n), nil
}

func extractSchema(data []byte) (int, error) {
	var manifest struct {
		Schema int `toml:"schema"`
	}
	if err := toml.Unmarshal(data, &manifest); err != nil {
		return 0, err
	}
	return manifest.Schema, nil
}

func extractVersion(data []byte) (string, error) {
	var manifest struct {
		Version string `toml:"version"`
	}
	if err := toml.Unmarshal(data, &manifest); err != nil {
		return "", err
	}
	return manifest.Version, nil
}

func extractHash(data []byte) (string, error) {
	var manifest struct {
		Hash string `toml:"hash"`
	}
	if err := toml.Unmarshal(data, &manifest); err != nil {
		return "", err
	}
	return manifest.Hash, nil
}

func extractPlatforms(data []byte) ([]string, error) {
	var manifest struct {
		IncludePlatforms []string `toml:"include_platforms"`
	}
	if err := toml.Unmarshal(data, &manifest); err != nil {
		return nil, err
	}
	return manifest.IncludePlatforms, nil
}
