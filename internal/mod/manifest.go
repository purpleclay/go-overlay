package mod

import (
	"crypto/sha256"
	"encoding/base64"
	"io"
	"slices"

	"github.com/BurntSushi/toml"
)

const (
	schemaVersion  = 1
	manifestHeader = "# Generated by govendor. DO NOT EDIT.\n\n"
)

type VendorManifest struct {
	Schema           int                        `toml:"schema"`
	Hash             string                     `toml:"hash"`
	IncludePlatforms []string                   `toml:"include_platforms,omitempty"`
	Workspace        map[string]WorkspaceMember `toml:"workspace,omitempty"`
	Mod              map[string]GoModule        `toml:"mod"`
}

// combineHash creates a hash that includes both the content hash and govendor version.
// This ensures manifests are regenerated when either dependencies or govendor changes.
func combineHash(contentHash, version string) string {
	h := sha256.New()
	h.Write([]byte(contentHash))
	h.Write([]byte(version))
	return "sha256-" + base64.StdEncoding.EncodeToString(h.Sum(nil))
}

type WorkspaceMember struct {
	Path      string `toml:"path"`
	GoVersion string `toml:"go,omitempty"`
}

type GoModule struct {
	Path         string   `toml:"-"`
	Version      string   `toml:"version"`
	Hash         string   `toml:"hash,omitempty"`
	GoVersion    string   `toml:"go,omitempty"`
	Packages     []string `toml:"packages,omitempty"`
	ReplacedPath string   `toml:"replaced,omitempty"`
	Local        string   `toml:"local,omitempty"`
}

func newManifest(goMod *GoModFile, extraPlatforms []string, version string) (*VendorManifest, error) {
	deps, err := goMod.Dependencies(extraPlatforms)
	if err != nil {
		return nil, err
	}

	mod := make(map[string]GoModule, len(deps))
	for _, m := range deps {
		mod[m.Path] = m
	}

	var platforms []string
	if len(extraPlatforms) > 0 {
		platforms = make([]string, len(extraPlatforms))
		copy(platforms, extraPlatforms)
		slices.Sort(platforms)
	}

	return &VendorManifest{
		Schema:           schemaVersion,
		Hash:             combineHash(goMod.Hash(), version),
		IncludePlatforms: platforms,
		Mod:              mod,
	}, nil
}

func newWorkspaceManifest(goWork *GoWorkFile, extraPlatforms []string, version string) (*VendorManifest, error) {
	deps, err := goWork.Dependencies(extraPlatforms)
	if err != nil {
		return nil, err
	}

	mod := make(map[string]GoModule, len(deps))
	for _, m := range deps {
		mod[m.Path] = m
	}

	var platforms []string
	if len(extraPlatforms) > 0 {
		platforms = make([]string, len(extraPlatforms))
		copy(platforms, extraPlatforms)
		slices.Sort(platforms)
	}

	workspace := goWork.WorkspaceDependencies()

	return &VendorManifest{
		Schema:           schemaVersion,
		Hash:             combineHash(goWork.Hash(), version),
		IncludePlatforms: platforms,
		Workspace:        workspace,
		Mod:              mod,
	}, nil
}

func (m *VendorManifest) WriteTo(w io.Writer) (int64, error) {
	n, err := io.WriteString(w, manifestHeader)
	if err != nil {
		return int64(n), err
	}

	encoder := toml.NewEncoder(w)
	if err := encoder.Encode(m); err != nil {
		return int64(n), err
	}

	return int64(n), nil
}

func extractHash(data []byte) (string, error) {
	var manifest struct {
		Hash string `toml:"hash"`
	}
	if err := toml.Unmarshal(data, &manifest); err != nil {
		return "", err
	}
	return manifest.Hash, nil
}

func extractPlatforms(data []byte) ([]string, error) {
	var manifest struct {
		IncludePlatforms []string `toml:"include_platforms"`
	}
	if err := toml.Unmarshal(data, &manifest); err != nil {
		return nil, err
	}
	return manifest.IncludePlatforms, nil
}
