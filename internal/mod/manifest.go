package mod

import (
	"io"

	"github.com/BurntSushi/toml"
)

const (
	schemaVersion  = 1
	manifestHeader = "# Generated by govendor. DO NOT EDIT.\n\n"
)

type VendorManifest struct {
	Schema int                 `toml:"schema"`
	Hash   string              `toml:"hash"`
	Mod    map[string]GoModule `toml:"mod"`
}

type GoModule struct {
	Path         string   `toml:"-"`
	Version      string   `toml:"version"`
	Hash         string   `toml:"hash"`
	GoVersion    string   `toml:"go,omitempty"`
	Packages     []string `toml:"packages,omitempty"`
	ReplacedPath string   `toml:"replaced,omitempty"`
	Local        string   `toml:"local,omitempty"`
}

func newManifest(goMod *GoModFile) (*VendorManifest, error) {
	deps, err := goMod.Dependencies()
	if err != nil {
		return nil, err
	}

	mod := make(map[string]GoModule, len(deps))
	for _, m := range deps {
		mod[m.Path] = m
	}

	return &VendorManifest{
		Schema: schemaVersion,
		Hash:   goMod.Hash(),
		Mod:    mod,
	}, nil
}

func (m *VendorManifest) WriteTo(w io.Writer) (int64, error) {
	n, err := io.WriteString(w, manifestHeader)
	if err != nil {
		return int64(n), err
	}

	encoder := toml.NewEncoder(w)
	if err := encoder.Encode(m); err != nil {
		return int64(n), err
	}

	return int64(n), nil
}

func extractHash(data []byte) (string, error) {
	var manifest struct {
		Hash string `toml:"hash"`
	}
	if err := toml.Unmarshal(data, &manifest); err != nil {
		return "", err
	}
	return manifest.Hash, nil
}
